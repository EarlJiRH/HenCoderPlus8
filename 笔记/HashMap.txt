HashMap
数组ArrayList(连续空间) 可能浪费内存空间,插入、删除的速度慢,查找的速度快(下标访问)
列表LinkedList(非连续空间) 不会浪费内存空间,插入、删除的速度快,查找的内存慢(从头到尾)

1.7(数组加列表)
(kay,value) 数组存放value 理论应通过遍历数组获取数组中的value,实际通过对key进行hash生成数组
的索引(int类型),取值的时候直接根据key的hash生成的索引在数组中取value,带出问题————哈希碰撞(解决方案:
value发生碰撞时,会改为通过列表保存当前value,通过(key,value,next...)的方式,取值的时候再通过
对列表的取值来获取)
Entry封装  列表节点

哈希碰撞  Map(key,value)  key进行hash获得int类型的索引值,可能会因为不同的key生成相同的索引。
            导致两个key指向同一个数组下标对象,就会有哈希碰撞的问题。
解决方法  通过对value数组的再次封装(key,value,next)当数组上下标的value对应多个key的时候，这时候
    value的数组下标位置的value会变成另外的一个列表形式,这个下标的值称为哈希桶(列表和单个值都可能),
    当再次有通过hash产生相同的key的索引就会一直在哈希桶Entry(数组)进行头插法  通过列表连接

哈希桶数组的大小范围问题(int默认取值范围过大)
            对kay的hash值进行取模(16) 实际转为2进制的(0-15) 进行与运算

初始化(16 0.75) 2^30(阈值)   数组默认大小 16 临界值 16*0.75=12
key=null  存放在数组下标[0]的哈希桶(列表)内



